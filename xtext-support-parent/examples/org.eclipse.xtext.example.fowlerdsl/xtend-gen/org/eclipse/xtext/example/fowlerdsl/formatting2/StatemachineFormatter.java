/**
 * generated by Xtext
 */
package org.eclipse.xtext.example.fowlerdsl.formatting2;

import com.google.inject.Inject;
import java.util.Arrays;
import java.util.function.Consumer;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.example.fowlerdsl.services.StatemachineGrammarAccess;
import org.eclipse.xtext.example.fowlerdsl.statemachine.Command;
import org.eclipse.xtext.example.fowlerdsl.statemachine.Event;
import org.eclipse.xtext.example.fowlerdsl.statemachine.State;
import org.eclipse.xtext.example.fowlerdsl.statemachine.Statemachine;
import org.eclipse.xtext.example.fowlerdsl.statemachine.StatemachinePackage;
import org.eclipse.xtext.example.fowlerdsl.statemachine.Transition;
import org.eclipse.xtext.formatting2.AbstractFormatter2;
import org.eclipse.xtext.formatting2.IFormattableDocument;
import org.eclipse.xtext.formatting2.IHiddenRegionFormatter;
import org.eclipse.xtext.formatting2.regionaccess.ISemanticRegion;
import org.eclipse.xtext.resource.XtextResource;
import org.eclipse.xtext.xbase.lib.Extension;
import org.eclipse.xtext.xbase.lib.Procedures.Procedure1;

@SuppressWarnings("all")
public class StatemachineFormatter extends AbstractFormatter2 {
  @Inject
  @Extension
  private StatemachineGrammarAccess _statemachineGrammarAccess;
  
  protected void _format(final Statemachine statemachine, @Extension final IFormattableDocument document) {
    EList<Event> _events = statemachine.getEvents();
    for (final Event events : _events) {
      this.format(events, document);
    }
    EList<Command> _commands = statemachine.getCommands();
    for (final Command commands : _commands) {
      this.format(commands, document);
    }
    EList<State> _states = statemachine.getStates();
    for (final State states : _states) {
      this.format(states, document);
    }
  }
  
  protected void _format(final State state, @Extension final IFormattableDocument document) {
    final Procedure1<IHiddenRegionFormatter> _function = (IHiddenRegionFormatter it) -> {
      it.oneSpace();
    };
    final Procedure1<IHiddenRegionFormatter> _function_1 = (IHiddenRegionFormatter it) -> {
      it.indent();
    };
    document.<ISemanticRegion, ISemanticRegion>interior(
      document.append(this.textRegionExtensions.regionFor(state).keyword("state"), _function), 
      this.textRegionExtensions.regionFor(state).keyword("end"), _function_1);
    String _name = state.getName();
    boolean _tripleNotEquals = (_name != null);
    if (_tripleNotEquals) {
      final Procedure1<IHiddenRegionFormatter> _function_2 = (IHiddenRegionFormatter it) -> {
        it.oneSpace();
      };
      document.prepend(this.textRegionExtensions.regionFor(state).feature(StatemachinePackage.Literals.STATE__NAME), _function_2);
    }
    final Procedure1<IHiddenRegionFormatter> _function_3 = (IHiddenRegionFormatter it) -> {
      it.newLine();
    };
    final Procedure1<IHiddenRegionFormatter> _function_4 = (IHiddenRegionFormatter it) -> {
      it.oneSpace();
    };
    document.append(document.prepend(this.textRegionExtensions.regionFor(state).keyword("actions"), _function_3), _function_4);
    final Procedure1<IHiddenRegionFormatter> _function_5 = (IHiddenRegionFormatter it) -> {
      it.newLine();
    };
    final Procedure1<IHiddenRegionFormatter> _function_6 = (IHiddenRegionFormatter it) -> {
      it.newLine();
    };
    final Procedure1<IHiddenRegionFormatter> _function_7 = (IHiddenRegionFormatter it) -> {
      it.indent();
    };
    document.<ISemanticRegion, ISemanticRegion>interior(
      document.append(this.textRegionExtensions.regionFor(state).keyword("{"), _function_5), 
      document.append(this.textRegionExtensions.regionFor(state).keyword("}"), _function_6), _function_7);
    final Procedure1<IHiddenRegionFormatter> _function_8 = (IHiddenRegionFormatter it) -> {
      it.setNewLines(1, 1, 2);
    };
    document.<State>append(state, _function_8);
    EList<Command> _actions = state.getActions();
    for (final Command command : _actions) {
      document.<Command>format(command);
    }
    EList<Transition> _transitions = state.getTransitions();
    for (final Transition transitions : _transitions) {
      this.format(transitions, document);
    }
  }
  
  protected void _format(final Transition transition, @Extension final IFormattableDocument document) {
    final Consumer<ISemanticRegion> _function = (ISemanticRegion it) -> {
      final Procedure1<IHiddenRegionFormatter> _function_1 = (IHiddenRegionFormatter it_1) -> {
        it_1.oneSpace();
      };
      document.surround(it, _function_1);
    };
    this.textRegionExtensions.regionFor(transition).keywords("=>", "(", ")").forEach(_function);
    final Procedure1<IHiddenRegionFormatter> _function_1 = (IHiddenRegionFormatter it) -> {
      it.setNewLines(1, 1, 2);
    };
    document.<Transition>append(transition, _function_1);
    document.<Event>format(transition.getEvent());
  }
  
  public void format(final Object state, final IFormattableDocument document) {
    if (state instanceof XtextResource) {
      _format((XtextResource)state, document);
      return;
    } else if (state instanceof State) {
      _format((State)state, document);
      return;
    } else if (state instanceof Statemachine) {
      _format((Statemachine)state, document);
      return;
    } else if (state instanceof Transition) {
      _format((Transition)state, document);
      return;
    } else if (state instanceof EObject) {
      _format((EObject)state, document);
      return;
    } else if (state == null) {
      _format((Void)null, document);
      return;
    } else if (state != null) {
      _format(state, document);
      return;
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(state, document).toString());
    }
  }
}
